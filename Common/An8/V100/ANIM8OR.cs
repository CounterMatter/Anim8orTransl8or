// Copyright © 2018 Contingent Games.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// This code was manually generated based on:
//    http://www.anim8or.com/learn/specs/an8_format.txt
//
// Note: Some chunks in v1.00 are currently undocumented.
//
// It is intended to be similar to code generated by xsd.exe.

using System;

namespace Anim8orTransl8or.An8.V100
{
   public class ANIM8OR
   {
      /// <summary>
      /// Contains version number and related data.
      /// </summary>
      public header header;

      /// <summary>
      /// String with user's description of the file.
      /// </summary>
      public description description;

      /// <summary>
      /// Frame rate and ground grid settings.
      /// </summary>
      public environment environment;

      /// <summary>
      /// Description of texture files used.
      /// </summary>
      public texture[] texture;

      /// <summary>
      /// Global materials.
      /// </summary>
      public material[] material;

      /// <summary>
      /// Objects.
      /// </summary>
      public @object[] @object;

      /// <summary>
      /// Figures.
      /// </summary>
      public figure[] figure;

      /// <summary>
      /// Sequences.
      /// </summary>
      public sequence[] sequence;

      /// <summary>
      /// Scenes.
      /// </summary>
      public scene[] scene;
   }

   #region common
   public class empty
   {
   }

   public class @int
   {
      public Int64 text;
   }

   public class @float
   {
      public Double text;
   }

   public class @string
   {
      public String text;
   }

   public class @wstring
   {
      public String text;
   }
   #endregion

   #region header
   public class header
   {
      /// <summary>
      /// The version string has the form <major> "." <minor> such as "0.85".
      /// It can have additional information at the end as well such as
      /// "0.85beta"
      /// </summary>
      public @string version;

      /// <summary>
      /// The build string is used to identify the build number of the Anim8or
      /// executable that created the.an8 file.
      /// </summary>
      public @string build;
   }
   #endregion

   #region description
   public class description
   {
      /// <summary>
      /// Normally description strings represent a single line of text and are
      /// terminated with a <cr> <lf>:
      ///
      /// "This is my alien model.\0d\0a"
      ///
      /// Anim8or truncates descriptions to 4096 characters when reading them.
      /// </summary>
      public String[] text;
   }
   #endregion

   #region environment
   public class environment
   {
      /// <summary>
      /// Specifies the modeling grid's behavior.
      /// </summary>
      public grid grid;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public lighting lighting;

      /// <summary>
      /// Sets the Scene and Sequence playback frame rate.  Ignored unless the
      /// <limitplayback> chunk also appears.
      /// </summary>
      public @int framerate;

      /// <summary>
      /// Limits the playback frame rate to the value in <framerate>, or to a
      /// default value if no <framerate> chunk is present.
      /// </summary>
      public empty limitplayback;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public film film;
   }

   public class grid
   {
      /// <summary>
      /// If the first int is non-zero then auto-grid is enabled and the grid
      /// size is automatically determined by the view. If it's zero then the
      /// three following values set the grid spacing.
      /// </summary>
      public Int64 autogrid;

      /// <summary>
      /// The modeling grid spacing.
      /// </summary>
      public Double modelinggridspacing;

      /// <summary>
      /// The Scene editor's grid spacing.
      /// </summary>
      public Double scenegridspacing;

      /// <summary>
      /// The ground floor's grid size.
      /// </summary>
      public Double groundfloorgridsize;
   }

   public class lighting
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public @float intensity;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public @float ambientintensity;
   }

   #region film
   public class film
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public size size;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public ratio ratio;
   }

   public class size
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Int64 x;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Int64 y;
   }

   public class ratio
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Double numerator;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Double denominator;
   }
   #endregion
   #endregion

   #region texture
   public class texture
   {
      /// <summary>
      /// Define a texture name and bind it to an image file or files. The
      /// string <name> is the name used within Anim8or for this texture.
      /// </summary>
      public String name;

      /// <summary>
      /// <invert> is an optional empty chunk. If present then the image(s)
      /// for this texture are inverted top to bottem before they are used.
      /// </summary>
      public empty invert;

      /// <summary>
      /// <cubemap> is an optional empty chunk. It indicates that this texture
      /// is a cube map.
      /// </summary>
      public empty cubemap;

      /// <summary>
      /// The <file> chunks contain a single string for the name of the files
      /// that hold the texture image. Only one <file> chunk is used for normal
      /// textures and six <file> chunks are used for cube map textures.
      /// </summary>
      public @string[] file;
   }
   #endregion

   #region material
   public class material
   {
      /// <summary>
      /// The name of the material is given by <name>.
      /// </summary>
      public String name;

      /// <summary>
      /// The front and back surfaces are described by the other chunks.
      /// </summary>
      public surface surface;

      /// <summary>
      /// Single sided materials don't have the <backsurface> chunk while two
      /// sided materials do.
      /// </summary>
      public surface backsurface;
   }

   #region surface
   public class surface
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing. It appears to be
      /// deprecated.
      /// </summary>
      public rgb rgb;

      /// <summary>
      /// <ambiant>, <diffuse>, <specular> and <emissive> chunks describe the
      /// respective colors and constant weights, and if there is a
      /// corresponding texture what it is. Yes, I know <ambiant> is
      /// misspelled.
      /// </summary>
      public ambiant ambiant;

      /// <summary>
      /// <ambiant>, <diffuse>, <specular> and <emissive> chunks describe the
      /// respective colors and constant weights, and if there is a
      /// corresponding texture what it is. Yes, I know <ambiant> is
      /// misspelled.
      /// </summary>
      public ambiant diffuse;

      /// <summary>
      /// <ambiant>, <diffuse>, <specular> and <emissive> chunks describe the
      /// respective colors and constant weights, and if there is a
      /// corresponding texture what it is. Yes, I know <ambiant> is
      /// misspelled.
      /// </summary>
      public ambiant specular;

      /// <summary>
      /// <ambiant>, <diffuse>, <specular> and <emissive> chunks describe the
      /// respective colors and constant weights, and if there is a
      /// corresponding texture what it is. Yes, I know <ambiant> is
      /// misspelled.
      /// </summary>
      public ambiant emissive;

      /// <summary>
      /// <alpha> is a int-const chunk that sets the overall transparency of
      /// the material. 255 is opaque and 0 is completely transparent. Values
      /// are clamped to this range.
      /// </summary>
      public @int alpha;

      /// <summary>
      /// <brilliance> is a float chunk that sets the brilliance factor.
      /// </summary>
      public @float brilliance;

      /// <summary>
      /// <phongsize> is a float chunk that sets the phong roughness factor.
      /// </summary>
      public @float phongsize;

      /// <summary>
      /// <map>* is one of multiple chunks that describe a texture map used for
      /// things other than the four colors: ambient, diffuse, specular, and
      /// emissive. Currently supported uses are for transparency, bump map,
      /// and environment map.
      /// </summary>
      public map[] map;

      /// <summary>
      /// TODO: I think the spec incorrectly calls this "lockambdiff".
      /// <lockambdiff> is an empty chunk that, if present, uses the diffuse
      /// values for both the diffuse and ambient color properties.
      /// </summary>
      public empty lockambientdiffuse;
   }

   public class rgb
   {
      /// <summary>
      /// The integer values representing the red component of a color. It is
      /// clamped to 0 to 255, then scaled so to the range 0.0 to 1.0
      /// representing the darkest and brightest values.
      /// </summary>
      public Int64 red;

      /// <summary>
      /// The integer values representing the green component of a color. It is
      /// clamped to 0 to 255, then scaled so to the range 0.0 to 1.0
      /// representing the darkest and brightest values.
      /// </summary>
      public Int64 green;

      /// <summary>
      /// The integer values representing the blue component of a color. It is
      /// clamped to 0 to 255, then scaled so to the range 0.0 to 1.0
      /// representing the darkest and brightest values.
      /// </summary>
      public Int64 blue;
   }

   #region ambiant
   public class ambiant
   {
      /// <summary>
      /// <rgb> is the basc color.
      /// </summary>
      public rgb rgb;

      /// <summary>
      /// <factor> is a float chunk with the ambient weighting factor.
      /// </summary>
      public @float factor;

      /// <summary>
      /// <texturename> is a string containing the name of the texture used in
      /// the diffuse color. This is not the file name but the internal name.
      /// </summary>
      public @string texturename;

      /// <summary>
      /// <textureparams> describe how the texture is blended with the base
      /// color.
      /// </summary>
      public textureparams textureparams;
   }

   #region textureparams
   public class textureparams
   {
      /// <summary>
      /// <blendmode> and <alphamode> specifies how that a texture will be
      /// combined with the base color.
      /// </summary>
      public blendmode blendmode;

      /// <summary>
      /// <blendmode> and <alphamode> specifies how that a texture will be
      /// combined with the base color.
      /// </summary>
      public alphamode alphamode;

      /// <summary>
      /// <percent> holds a single signed integer pecentage that is used to
      /// blend the overall strength of the texture. If it is 100 then the
      /// combined result is used as the final color. If it is 50 percent then
      /// the combined color is averaged with the base color. For bumpmaps
      /// <percent> is the strength of the bumps and can go from -100 to 100
      /// perxent.
      /// </summary>
      public @int percent;
   }

   #region blendmode
   public class blendmode
   {
      /// <summary>
      /// The blendmode chunk hold a single identifier from the list above.
      /// </summary>
      public blendmodeenum text;
   }

   public enum blendmodeenum
   {
      /// <summary>
      /// decal means that the texture color replaces the base color.
      /// </summary>
      decal,

      /// <summary>
      /// darken means that the texture's color is multiplied by the base
      /// color.
      /// </summary>
      darken,

      /// <summary>
      /// lighten adds the texture color.
      /// </summary>
      lighten,
   }
   #endregion

   #region alphamode
   public class alphamode
   {
      /// <summary>
      /// The alphamode chuck also holds a single identifier. Note: alphamode
      /// only applies to the diffuse color and is overridden by the
      /// transparency texture if it is present.
      /// </summary>
      public alphamodeenum text;
   }

   public enum alphamodeenum
   {
      /// <summary>
      /// none means that the alpha component is ignored.
      /// </summary>
      none,

      /// <summary>
      /// layer blends the texture color with the base color proportional to
      /// the value of the alpha component.
      /// </summary>
      layer,

      /// <summary>
      /// final uses the texture's alpha component as the transparency value
      /// for the final material color.
      /// </summary>
      final,
   }
   #endregion
   #endregion
   #endregion

   public class map
   {
      /// <summary>
      /// The <kind> chunk says how it will be used. The <$string> parameter
      /// can be "transparency", "bumpmap" or "environment", or it can be one
      /// of the four color textures "ambiant", "diffuse", "specular", and
      /// "emissive". Other values are ignored. If a color texture is specified
      /// in both a color component such as the <diffuse> chunk and in a <map>
      /// component the last one in the file will be used.
      /// </summary>
      public @string kind;

      /// <summary>
      /// The <texturename> chunk names which texture it is.
      /// </summary>
      public @string texturename;

      /// <summary>
      /// The <textureparams> specify the strength, etc.
      /// </summary>
      public textureparams textureparams;
   }
   #endregion
   #endregion

   #region object
   public class @object
   {
      /// <summary>
      /// The object's name is given by <name>.
      /// </summary>
      public String name;

      /// <summary>
      /// <material> chunks in an <object> chunk are local to that object and
      /// cannot be used in other objects. There can be any number of
      /// <material> and <component> chunks in any order. Normally the
      /// <material> chunks are output first by Anim8or.
      /// </summary>
      public material[] material;

      /// <summary>
      /// A <component> is any one of the listed chunk types.  All <component>
      /// types of chunks have a <name> string as the first value. They also
      /// may have both a <base> and a <pivot> chunk. <namedobject> components
      /// can only appear inside of a <bone> chunk as part of a <figure>.
      /// </summary>
      public mesh[] mesh;
      public sphere[] sphere;
      public cylinder[] cylinder;
      public cube[] cube;
      public subdivision[] subdivision;
      // TODO: I think the spec incorrectly calls this "path".
      public pathcom[] pathcom;
      public textcom[] textcom;
      public modifier1[] modifier;
      public image[] image;
      public group1[] group;
      // TODO: morphtarget?
   }

   #region mesh
   public class mesh
   {
      /// <summary>
      /// The mesh's name is given by <name>.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// <material> is the material used for new faces when they are added to
      /// a mesh. Even though a <material> chunk may contain a full material
      /// description, only the name component is used here. The material
      /// should be defined elsewhere, either in the global materials of the
      /// Object's local materials.
      /// </summary>
      public material material;

      /// <summary>
      /// This is the threshold angle in degrees that determines if an edge is
      /// as a crease or is smooth. Angles larger than the threshold are shown
      /// as creases or corners; those equal or smaller are shown as smooth.
      /// The default value is 45 degrees.
      /// </summary>
      public @float smoothangle;

      /// <summary>
      /// This is a list of material in a Mesh. They are numbered from 0.
      /// Material 0 is the default material.
      /// </summary>
      public materiallist materiallist;

      /// <summary>
      /// These points are the basic vertices used to form the Mesh. They are
      /// numbered from 0.
      /// </summary>
      public points points;

      /// <summary>
      /// The normals are stored as unit length vectors. This chunk is not
      /// usually present and is ignored by Anim8or. It will be output if the
      /// Options->Debug->OutputNormals flag has been set for use by other
      /// applications.
      /// </summary>
      public normals normals;

      /// <summary>
      /// A list of edges. Edges are not normally output by Anim8or as this
      /// information is already present in the <facedata> chunk. When an edge
      /// either 1) isn't used in any face, or 2) has some special properties
      /// set by the user, it will be listed here. Optionally, all edges can be
      /// output with the Options->Debug->OutputEdges flag.
      /// </summary>
      public edges edges;

      /// <summary>
      /// The UV values used for texture coordinates. These are indexed
      /// starting at zero.
      /// </summary>
      public texcoords texcoords;

      /// <summary>
      /// One set of <facedata> data is listed for each face.
      /// </summary>
      public faces faces;
   }

   #region base
   public class @base
   {
      /// <summary>
      /// This chunk represents the location of the component. If not present
      /// then the component is located at (0, 0, 0).
      /// </summary>
      public origin origin;

      /// <summary>
      /// This chunk holds the orientation of the component as a quaternion. If
      /// not present the it is unrotated, with the X coordinate pointing to
      /// the right, the Y pointing up, and the Z pointing out of the screen in
      /// a front view of an object.
      ///
      /// For a description of the wonders of quaternions, see a good graphics
      /// text, or the original paper by Ken Shoemaker.
      /// </summary>
      public orientation orientation;
   }

   public class origin
   {
      public point point;
   }

   public class orientation
   {
      public quaternion quaternion;
   }
   #endregion

   public class pivot
   {
      public origin origin;
      public orientation orientation;
   }

   public class materiallist
   {
      /// <summary>
      /// The value of <$string> is a material name. It should be defined
      /// either as a global material or as a material local to this Object.
      /// </summary>
      public @string[] materialname;
   }

   public class points
   {
      public point[] point;
   }

   public class normals
   {
      public point[] point;
   }

   #region edges
   public class edges
   {
      public edge[] edge;
   }

   public class edge
   {
      /// <summary>
      /// The first two values in an edge are indices into the points array for
      /// the ends of the edge. The index of the first point is always less
      /// than that of the second.
      /// </summary>
      public Int64 startpointindex;

      /// <summary>
      /// The first two values in an edge are indices into the points array for
      /// the ends of the edge. The index of the first point is always less
      /// than that of the second.
      /// </summary>
      public Int64 endpointindex;

      /// <summary>
      /// The third value, if present, is the user set sharpness value. If this
      /// Mesh is subdivided then this edge will not be smoothed with the
      /// adjacent edges for this number of times, creating a relative sharp
      /// corner in the surface. If the value is -1 then it is always shown as
      /// Creased despite the actual angle is makes.
      /// </summary>
      public Int64 sharpness;
   }
   #endregion

   public class texcoords
   {
      public texcoord[] texcoord;
   }

   #region faces
   public class faces
   {
      public facedata[] facedata;
   }

   #region facedata
   public class facedata
   {
      /// <summary>
      /// NUMPOINTS is an <int-const> giving the number of sides in this face.
      /// It must be at least 3. Each face can have a different number of
      /// sides.
      /// </summary>
      public Int64 numpoints;

      /// <summary>
      /// FLAGS is an <int-const> with each bit as a flag describing what kinds
      /// of data this face has, and other properties of the face.
      /// </summary>
      public facedataenum flags;

      /// <summary>
      /// MATNO is an <int-const> for which material to use on this face. It is
      /// an index into the materials listed in the <materiallist> chuck for
      /// this Mesh.
      /// </summary>
      public Int64 matno;

      /// <summary>
      /// FLATNORMALNO - The index of the faces normal in the normal array for
      /// this Mesh. This value is normally set to -1 indicating that there is
      /// no face normal stored in the file.
      /// </summary>
      public Int64 flatnormalno;

      /// <summary>
      /// POINTDATA - This is one or more <int-const>s, depending on the value
      /// of FLAGS. For example:
      ///
      ///     faces {
      ///         3 5 0 -1 ( (2 6) (0 5) (1 7) )
      ///         3 5 2 -1 ( (3 8) (0 5) (2 3) )
      ///         4 5 2 -1 ( (4 9) (5 10) (1 7) (2 6) )
      ///     }
      ///
      /// shows a Mesh with 3 faces. The first two have 3 sides and the third
      /// one has 4. They all have texture coordinates (bit 4 is set in the
      /// flags field) and no face normals (the face normal value is -1). The
      /// first face uses material number 0 and the other two use material
      /// number 2.
      /// </summary>
      public pointdata[] pointdata;
   }

   [Flags]
   public enum facedataenum : Int64
   {
      /// <summary>
      /// 1 - SF_SHOW_BACK - Don't backface cull this face.
      /// </summary>
      showback = 1,

      /// <summary>
      /// 2 - SF_HAS_NORMALS - This face has normal data in this file.
      /// </summary>
      hasnormals = 2,

      /// <summary>
      /// 4 - SF_HAS_TEXTURE - This face has texture coordinates.
      /// <summary>
      hastexture = 4,
   }

   public class pointdata
   {
      /// <summary>
      /// The first value, which is always present, is an index into the
      /// <points> array for the location of the vertex.
      /// </summary>
      public Int64 pointindex;

      /// <summary>
      /// If the SF_HAS_NORMALS bit is on then it is followed by the index on
      /// the point's normal in the <normals> array. Note: this normal data is
      /// not used by Anim8or. It can optionally be exported, however, to help
      /// other programs use Anim8or data more easily.
      /// </summary>
      public Int64 normalindex;

      /// <summary>
      /// Finally if the SF_HAS_TEXTURE bit is set then a texture coordinate is
      /// present as the last value.
      /// </summary>
      public Int64 texcoordindex;
   }
   #endregion
   #endregion
   #endregion

   #region sphere
   public class sphere
   {
      /// <summary>
      /// The sphere's name is given by <name>.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// <material> is the material used for new faces when they are added to
      /// a mesh. Even though a <material> chunk may contain a full material
      /// description, only the name component is used here. The material
      /// should be defined elsewhere, either in the global materials of the
      /// Object's local materials.
      /// </summary>
      public material material;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public @float diameter;

      /// <summary>
      /// The two integers are the number of divisions used to make the Sphere
      /// in the vertical and horizontal directions.
      /// </summary>
      public longlat longlat;

      /// <summary>
      /// A geodesic sphere is built from a octahedron whose faces are divided
      /// into smaller triangles. Each original edge is divide into <$int>
      /// edges and the faces are split accordingly into smaller triangles. The
      /// vertices are then projected onto a Shpere.
      /// </summary>
      public @int geodesic;
   }

   public class longlat
   {
      public Int64 longitude;
      public Int64 latitude;
   }
   #endregion

   public class cylinder
   {
      /// <summary>
      /// The cylinder's name is given by <name>.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// <material> is the material used for new faces when they are added to
      /// a mesh. Even though a <material> chunk may contain a full material
      /// description, only the name component is used here. The material
      /// should be defined elsewhere, either in the global materials of the
      /// Object's local materials.
      /// </summary>
      public material material;

      /// <summary>
      /// This is the length of the cylinder.
      /// </summary>
      public @float length;

      /// <summary>
      /// This is the diameter of the start of the cylinder. It is also the
      /// diameter of the end if the <topdiameter> chunk is not present. If one
      /// of thee values is 0 then that end of the cylinder is collapsed into a
      /// single point resulting is a Cone.
      /// </summary>
      public @float diameter;

      /// <summary>
      /// The diameter of the end of the cylinder.
      /// </summary>
      public @float topdiameter;

      /// <summary>
      /// The two integers are the number of divisions used to make the
      /// Cylinder in the vertical and horizontal directions.
      /// </summary>
      public longlat longlat;

      /// <summary>
      /// Cap the start of the cylinder if this chunk is present.
      /// </summary>
      public empty capstart;

      /// <summary>
      /// Cap the end of the cylinder if this chunk is present.
      /// </summary>
      public empty capend;
   }

   #region cube
   public class cube
   {
      /// <summary>
      /// The cube's name is given by <name>.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// <material> is the material used for new faces when they are added to
      /// a mesh. Even though a <material> chunk may contain a full material
      /// description, only the name component is used here. The material
      /// should be defined elsewhere, either in the global materials of the
      /// Object's local materials.
      /// </summary>
      public material material;

      /// <summary>
      /// The dimensions of the cube in the X, Y and Z directions.
      /// </summary>
      public scale scale;

      /// <summary>
      /// The number of divisions along the X, Y and Z axis.
      /// </summary>
      public divisions divisions;
   }

   public class scale
   {
      public Double x;
      public Double y;
      public Double z;
   }

   public class divisions
   {
      public Int64 x;
      public Int64 y;
      public Int64 z;
   }
   #endregion

   #region subdivision
   public class subdivision
   {
      /// <summary>
      /// The subdivision's name is given by <name>.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// <material> is the material used for new faces when they are added to
      /// a mesh. Even though a <material> chunk may contain a full material
      /// description, only the name component is used here. The material
      /// should be defined elsewhere, either in the global materials of the
      /// Object's local materials.
      /// </summary>
      public material material;

      /// <summary>
      /// This is the threshold angle in degrees that determines if an edge is
      /// as a crease or is smooth. Angles larger than the threshold are shown
      /// as creases or corners; those equal or smaller are shown as smooth.
      /// The default value is 45 degrees.
      /// </summary>
      public @float smoothangle;

      /// <summary>
      /// The number of times a that this component will be subdivided in the
      /// working views.
      /// </summary>
      public @int working;

      /// <summary>
      /// The number of times a that this component will be subdivided in the
      /// rendered views. This value is currently not used by Anim8or.
      /// </summary>
      public @int divisions;

      /// <summary>
      /// This is a list of material in a subdivision. They are numbered from
      /// 0. Material 0 is the default material.
      /// </summary>
      public materiallist materiallist;

      /// <summary>
      /// These points are the basic vertices used to form the subdivision.
      /// They are numbered from 0.
      /// </summary>
      public points points;

      /// <summary>
      /// The normals are stored as unit length vectors. This chunk is not
      /// usually present and is ignored by Anim8or. It will be output if the
      /// Options->Debug->OutputNormals flag has been set for use by other
      /// applications.
      /// </summary>
      public normals normals;

      /// <summary>
      /// A list of edges. Edges are not normally output by Anim8or as this
      /// information is already present in the <facedata> chunk. When an edge
      /// either 1) isn't used in any face, or 2) has some special properties
      /// set by the user, it will be listed here. Optionally, all edges can be
      /// output with the Options->Debug->OutputEdges flag.
      /// </summary>
      public edges edges;

      /// <summary>
      /// The UV values used for texture coordinates. These are indexed
      /// starting at zero.
      /// </summary>
      public texcoords texcoords;

      /// <summary>
      /// One set of <facedata> data is listed for each face.
      /// </summary>
      public faces faces;
   }
   #endregion

   #region pathcom
   public class pathcom
   {
      /// <summary>
      /// The path's name is given by <name>.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// TODO: What does this mean?
      /// </summary>
      public empty extendable;

      /// <summary>
      /// A <path> is built from one or more Bezier splines. Multiple splines
      /// can be used to cut holes or to define separate, unconnected regions.
      /// </summary>
      public bezier bezier;
   }

   #region bezier
   public class bezier
   {
      /// <summary>
      /// If this chunk is present the first and last knots in the spline are
      /// connected to form a closed loop. Otherwise they are not.
      /// </summary>
      public empty closed;

      /// <summary>
      /// The first <point> is the location of the knot. The next two are the
      /// forward and reverse direction vectors. If present the <$int> value is
      /// the number of segments in the segment that begins with this knot. If
      /// not then the number is automatically determined when it is used.
      /// </summary>
      public knot[] knot;
   }

   public class knot
   {
      /// <summary>
      /// The first <point> is the location of the knot.
      /// </summary>
      public point location;

      /// <summary>
      /// The forward direction vector.
      /// </summary>
      public point forwarddirectionvector;

      /// <summary>
      /// The reverse direction vector.
      /// </summary>
      public point reversedirectionvector;

      /// <summary>
      /// TODO: Will this ever appear?
      /// If present the <$int> value is the number of segments in the segment
      /// that begins with this knot. If not then the number is automatically
      /// determined when it is used.
      /// </summary>
      //public Int64 numberofsegments;

      /// <summary>
      /// If this is present the knot is a corner knot and can have a
      /// discontinuous first derivative. If it is not present then the values
      /// of the forward and reverse direction vectors should be the negation
      /// of each other.
      /// </summary>
      public empty corner;
   }
   #endregion
   #endregion

   public class textcom
   {
      /// <summary>
      /// A <texcom> is a True-Type string represented by one or more splines.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// This is a Unicode string. Values outside of the 7 bit printable ASCII
      /// character set are escaped by a backslash "\" and are written as
      /// either 3 or 6 octal digits representing the value of the Unicode
      /// character. Six octal digits are used if either the value is greater
      /// than decimal 255 or the following letter is a digit. When reading
      /// these strings in the digits following a back slash are read and
      /// converted into an octal value until either the next character is not
      /// an octal digits or 6 digits have been read. For example, the Euro
      /// currency symbol could be represented by:
      ///
      ///     L"\020254"
      ///
      /// since it has a hexadecimal value of 0x20ac which is the octal value
      /// of 020254.
      ///
      /// Note: Unicode symbols are not supported in Win95, Win98, WinSE or
      /// WinME
      /// </summary>
      public @wstring @string;

      /// <summary>
      /// TODO: What does this mean?
      /// </summary>
      public @string typeface;

      /// <summary>
      /// TODO: What does this mean? Is it float or int?
      /// </summary>
      public @float size;

      /// <summary>
      /// TODO: What does this mean?
      /// </summary>
      public empty bold;

      /// <summary>
      /// TODO: What does this mean?
      /// </summary>
      public empty italic;
   }

   #region modifier
   public class modifier1
   {
      /// <summary>
      /// A <modifier> chunk defines the size, location and kind of a modifier
      /// and any <component> that it is bound to.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// TODO: What does this mean?
      /// </summary>
      public @float length;

      /// <summary>
      /// TODO: What does this mean?
      /// </summary>
      public @float diameter;

      /// <summary>
      /// The number of vertical segments that the modifier is divided into.
      /// </summary>
      public @int segments;

      /// <summary>
      /// The kind of modifier. For example a taper modifier with
      /// a strength of 0.5 would look like:
      ///
      ///     method { modifier "taper"
      ///         parameter { "taper" 0.5 }
      ///     }
      ///
      /// since it has a single parameter.
      /// </summary>
      public method method;

      public mesh mesh;
      public sphere sphere;
      public cylinder cylinder;
      public cube cube;
      public subdivision subdivision;
      // TODO: I think the spec incorrectly calls this "path".
      public pathcom pathcom;
      public textcom textcom;
      public modifier1 modifier;
      public image image;
      public group1 group;
   }

   #region method
   public class method
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public methodenum text;

      /// <summary>
      /// <$string> names the modifier function and the <parameters> define how
      /// it behaves.
      /// </summary>
      public String modifierfunctionname;

      /// <summary>
      /// A named parameter to a modifier.
      /// </summary>
      public parameter[] parameter;
   }

   public enum methodenum
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      modifier,
   }

   public class parameter
   {
      /// <summary>
      /// <$string> is the name of the parameter.
      /// </summary>
      public String name;

      /// <summary>
      /// <$float> is its value.
      /// </summary>
      public Double value;
   }
   #endregion
   #endregion

   public class image
   {
      /// <summary>
      /// A reference image.
      /// </summary>
      public @string name;

      /// <summary>
      /// TODO: I think the spec incorrectly says this is a <$string>.
      /// The <$string> value is the name of the file with
      /// the image, or an empty string if it is undefined.
      /// </summary>
      public @string[] file;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// The int values are the size of the image in x and y dimensions.
      /// </summary>
      public size size;
   }

   public class group1
   {
      /// <summary>
      /// A <group> is a collection of zero of more <components>.
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      public mesh[] mesh;
      public sphere[] sphere;
      public cylinder[] cylinder;
      public cube[] cube;
      public subdivision[] subdivision;
      // TODO: I think the spec incorrectly calls this "path".
      public pathcom[] pathcom;
      public textcom[] textcom;
      public modifier1[] modifier;
      public image[] image;
      public group1[] group;
   }
   #endregion

   #region figure
   public class figure
   {
      /// <summary>
      /// A figure. <$string> is the name of the figure.
      /// </summary>
      public String name;

      /// <summary>
      /// Any defined materials are local to this figure.
      /// </summary>
      public material[] material;

      /// <summary>
      /// <bone> is the root bone, which contains all other bones.
      /// </summary>
      public bone1 bone;
   }

   public class bone1
   {
      /// <summary>
      /// The bone's name is given by <name>.
      /// </summary>
      public String name;

      /// <summary>
      /// <length> is the length of the bone.
      /// </summary>
      public @float length;

      /// <summary>
      /// <diameter> is the relative diameter of the bone when it is shown in
      /// the working views.
      /// </summary>
      public @float diameter;

      /// <summary>
      /// This chunk holds the orientation of the bone as a quaternion. If not
      /// present the it is unrotated, with the X coordinate pointing to the
      /// right, the Y pointing up, and the Z pointing out of the screen in a
      /// front view of an object.
      ///
      /// For a description of the wonders of quaternions, see a good graphics
      /// text, or the original paper by Ken Shoemaker.
      /// </summary>
      public orientation orientation;

      /// <summary>
      /// If this chunk is present then the bone joint cannot be edited.
      /// </summary>
      public empty locked;

      /// <summary>
      /// This chunk defines a degree of freedom for this done. There can be up
      /// to 3 instances of this chunk is a bone.
      /// </summary>
      public dof[] dof;

      /// <summary>
      /// If this chunk is present then the bone has a defined influence region
      /// and may be used in skinning.
      ///
      /// These six values defines two hierarchical "capsules", or a cylinders
      /// with hemispherical caps on the ends. When used in a skinning
      /// operation the relative weight of this bone on a point depends on
      /// where the point lies inside these capsules. If it is inside the inner
      /// capsule the relative weight is 1.0. If it is inside the outer capsule
      /// but not the inner one then the relative weight varies linearly
      /// between 0.0 at the outer capsule wall to 1.0 at the inner capsule
      /// wall. Outside the outer capsule the weight is 0.0.
      ///
      /// The final weight on a point is found by dividing the relative weight
      /// by the sum of all the relative weights for all bones. If this sum is
      /// 0.0 then a default weight of 1.0 is given to the parent bone of the
      /// point.
      /// </summary>
      public influence influence;

      public mesh[] mesh;
      public sphere[] sphere;
      public cylinder[] cylinder;
      public cube[] cube;
      public subdivision[] subdivision;
      // TODO: I think the spec incorrectly calls this "path".
      public pathcom[] pathcom;
      public textcom[] textcom;
      public modifier1[] modifier;
      public image[] image;
      public group1[] group;

      /// <summary>
      /// A <namedobject> is a reference to an <object> from within another
      /// part of Anim8or, such as a <figure>.
      /// </summary>
      public namedobject[] namedobject;

      public bone1[] bone;
   }

   public class dof
   {
      /// <summary>
      /// The value of <$string> is the axis and must be "X", "Y", or "Z".
      /// </summary>
      public String axis;

      /// <summary>
      /// The minimum angle that this angle may take on.
      /// </summary>
      public Double minimum;

      /// <summary>
      /// The default angle that this angle may take on.
      /// </summary>
      public Double @default;

      /// <summary>
      /// The maximum angle that this angle may take on.
      /// </summary>
      public Double maximum;

      /// <summary>
      /// If the <locked> chunk is present then this axis of rotation cannot be
      /// edited.
      /// </summary>
      public empty locked;

      /// <summary>
      /// If the <unlimited> chunk is present then there are no limits to this
      /// axis's rotation angle.
      /// </summary>
      public empty unlimited;
   }

   public class influence
   {
      /// <summary>
      /// center0 - The location along the bone of the center of the lower end
      /// of the influence volume.
      /// </summary>
      public Double center0;

      /// <summary>
      /// inRadius0 - The radius of the inner layer at center0.
      /// </summary>
      public Double inradius0;

      /// <summary>
      /// outRadius0 - The radius of the outer layer at center0.
      /// </summary>
      public Double outradius0;

      /// <summary>
      /// center1 - The location along the bone of the center of the uppper end
      /// of the influence volume.
      /// </summary>
      public Double center1;

      /// <summary>
      /// inRadius1 - The radius of the inner layer at center1.
      /// </summary>
      public Double inradius1;

      /// <summary>
      /// outRadius1 - The radius of the outer layer at center1.
      /// </summary>
      public Double outradius1;
   }

   #region namedobject
   public class namedobject
   {
      /// <summary>
      /// Note: The spec doesn't say what this is, but it is pretty obvious
      /// that this is the name of the object that is referenced.
      /// </summary>
      public String objectname;

      /// <summary>
      /// The namedobject's name is given by <name>.
      /// </summary>
      /// </summary>
      public @string name;

      /// <summary>
      /// A <base> chunk can have either an <origin>, an <orientation>, or
      /// both. This chunk gives the location and orientation of the component
      /// relative to it's parent. If the component is in a group then the
      /// group is it's parent, otherwise it is the Object.
      /// </summary>
      public @base @base;

      /// <summary>
      /// The <pivot> chunk specifies the location and orientation of the
      /// pivot, the coordinate system used when you interactively scale and
      /// rotate a component in the Object editor.
      /// </summary>
      public pivot pivot;

      /// <summary>
      /// <material> is the default material for this object but is currently
      /// ignored by Anim8or.
      /// </summary>
      public material material;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public @float scale;

      /// <summary>
      /// This object's shape is determined partially by the bone <$string>'s
      /// position in this figure.
      /// </summary>
      public @string[] weightedby;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public weights[] weights;
   }

   #region weights
   public class weights
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public String meshname;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public weightdata[] weightdata;
   }

   #region weightdata
   public class weightdata
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Int64 numweights;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public bonedata[] bonedata;
   }

   public class bonedata
   {
      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Int64 boneindex;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Double boneweight;
   }
   #endregion
   #endregion
   #endregion
   #endregion

   #region sequence
   public class sequence
   {
      /// <summary>
      /// The name of the sequence is given by <$string>.
      /// </summary>
      public String name;

      /// <summary>
      /// The name of the figure that this sequence applies to is defined by
      /// <$string>.
      /// </summary>
      public @string figure;

      /// <summary>
      /// This chunk is the length of the sequence in frames.
      /// </summary>
      public @int frames;

      /// <summary>
      /// The two strings give the names of the bone that it applies to, and
      /// the axis. The ais must be "X", "Y", or "Z".
      /// </summary>
      public jointangle[] jointangle;
   }

   #region jointangle
   public class jointangle
   {
      public String bone;
      public String axis;
      public floattrack track;

      // TODO: Are these part of jointangle?
      //public pointtrack track;
      //public qtrack track;
      //public booleantrack track;
   }

   #region floattrack
   public class floattrack
   {
      public floatkey[] floatkey;
   }

   public class floatkey
   {
      /// <summary>
      /// <$int> is the frame number for this key.
      /// </summary>
      public Int64 frame;

      /// <summary>
      /// <$float> is the value.
      /// </summary>
      public Double value;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Double value2;

      /// <summary>
      /// TODO: This was undocumented at the time of writing.
      /// </summary>
      public Double value3;

      /// <summary>
      /// <$string> is a string used to modify the behavior of this knot. It is
      /// currently ignored.
      /// </summary>
      public String modifier;
   }
   #endregion

   #region pointtrack
   public class pointtrack
   {
      public pointkey[] pointkey;
   }

   public class pointkey
   {
      /// <summary>
      /// <$int> is the frame number for this key.
      /// </summary>
      public Int64 frame;

      /// <summary>
      ///  The first <point> is the value.
      /// </summary>
      public point value;

      /// <summary>
      /// The second <point> is the forward direction vector and this know.
      /// </summary>
      public point forwarddirectionvector;

      /// <summary>
      /// The third <point> is the reverse direection vector.
      /// </summary>
      public point reversedirectionvector;

      /// <summary>
      /// <$string> is a string used to modify the behavior of this knot. It is
      /// currently ignored.
      /// </summary>
      public String modifier;
   }
   #endregion

   #region qtrack
   public class qtrack
   {
      public qkey[] qkey;
   }

   public class qkey
   {
      /// <summary>
      /// <$int> is the frame number for this key.
      /// </summary>
      public Int64 frame;

      /// <summary>
      /// <quaternion> is the value.
      /// </summary>
      public quaternion value;

      /// <summary>
      /// <$string> is a string used to modify the behavior of this knot. It is
      /// currently ignored.
      /// </summary>
      public String modifier;
   }
   #endregion

   #region booleantrack
   public class booleantrack
   {
      public booleankey[] booleankey;
   }

   public class booleankey
   {
      /// <summary>
      /// The first <$int> is the frame number for this key.
      /// </summary>
      public Int64 frame;

      /// <summary>
      /// The second <$int> is the value.  It must be 0 or 1.  0 means False
      /// and 1 means True.
      /// </summary>
      public Int64 value;

      /// <summary>
      /// <$string> is a string used to modify the behavior of this knot. It is
      /// currently ignored.
      /// </summary>
      public String modifier;
   }
   #endregion
   #endregion
   #endregion

   #region scene
   public class scene
   {
      /// <summary>
      /// The name of the scene is in  <$string>.
      /// </summary>
      public String name;

      /// <summary>
      /// The number of frames.  Must be greater than zero.
      /// </summary>
      public @int frames;

      /// <summary>
      /// If the value of <$int> is one the ground grid is drawn. If it is
      /// zero then it isn't
      /// </summary>
      public @int groundgrid;

      /// <summary>
      /// The value used for shadow bias when drawing shadows. The nominal
      /// value is 0.001.
      /// </summary>
      public @float shadowbias;

      /// <summary>
      /// The color used for the background. The three values are the red,
      /// green, and blue color values. 255 represents full brightness and 0
      /// represents black. If not present the default color of 102, 102, 153
      /// is used.
      /// </summary>
      public rgb background;

      /// <summary>
      /// The name of a file used for the background image. If the panorama
      /// chunk is present then it is a panoroma, otherwise it is a fixed
      /// background.
      /// </summary>
      public image1 image;

      /// <summary>
      /// The <color> chunk is the color of the fog in 3 ints, from 0 to 255.
      /// <fogstart> and <fogend> are float chunks giving the starting and
      /// ending distance from the camera of the fog transition zone.
      /// <fogpercent> is an int chunk for the maximum fog level, if it is less
      /// that 100. <radial> is an empty chunk. If present then the fog
      /// distance is computed as the radial distance from the camera,
      /// otherwise it is the distance from the z = 0 plane.
      /// </summary>
      public fog fog;

      /// <summary>
      /// If present, this sets the distance of the near clip planes.
      /// </summary>
      public @float znear;

      /// <summary>
      /// If present, this sets the distance of the far clip planes.
      /// </summary>
      public @float zfar;

      /// <summary>
      /// Cameras that are in a scene are defined by a <camera> chunk.
      /// </summary>
      public camera[] camera;

      /// <summary>
      /// Figures that are in a scene are defined by a <figureelement> chunk.
      /// </summary>
      public figureelement[] figureelement;

      /// <summary>
      /// Objects that are in a scene are defined by an <objectelement> chunk.
      /// </summary>
      public objectelement[] objectelement;

      /// <summary>
      /// Lights that are in a scene are defined by a <light> chunk.
      /// </summary>
      public light[] light;

      /// <summary>
      /// A <null> chunk, also referred to as a "target" element in Anim8or,
      /// defines a new coordinate system.They can contain child elements and
      /// their location and orientation is fully animatable. They do not
      /// render in camera views.
      /// </summary>
      public @null[] @null;
   }

   #region image
   public class image1
   {
      /// <summary>
      /// The name of a file used for the background image.
      /// </summary>
      public String file;

      /// <summary>
      /// The four values are the left and right longitude angles and the
      /// bottom and top latitude angles of the image. Looking into the screen
      /// in the front view is directly at <0, 0>. <-90, 0> is to the left,
      /// <+90, 0) the right.
      /// </summary>
      public panorama panorama;
   }

   public class panorama
   {
      /// <summary>
      /// The left longitude angle.
      /// </summary>
      public Double leftlongitude;

      /// <summary>
      /// The right longitude angle.
      /// </summary>
      public Double rightlongitude;

      /// <summary>
      /// The bottom latitude angle.
      /// </summary>
      public Double bottomlatitude;

      /// <summary>
      /// The top latitude angle.
      /// </summary>
      public Double toplatitude;
   }
   #endregion

   #region fog
   public class fog
   {
      /// <summary>
      /// The <color> chunk is the color of the fog in 3 ints, from 0 to 255.
      /// </summary>
      public rgb color;

      /// <summary>
      /// <fogstart> is a float chunk giving the starting distance from the
      /// camera of the fog transition zone.
      /// </summary>
      public @float fogstart;

      /// <summary>
      /// <<fogend> is a float chunk giving the ending distance from the camera
      /// of the fog transition zone.
      /// </summary>
      public @float fogend;

      /// <summary>
      /// <fogpercent> is an int chunk for the maximum fog level, if it is
      /// less that 100.
      /// </summary>
      public @int fogpercent;

      /// <summary>
      /// <radial> is an empty chunk. If present then the fog distance is
      /// computed as the radial distance from the camera, otherwise it is the
      /// distance from the z = 0 plane.
      /// </summary>
      public empty radial;
   }
   #endregion

   #region camera
   public class camera
   {
      /// <summary>
      /// <$string> - The first thing is the name of the element.
      /// </summary>
      public String name;

      /// <summary>
      /// <loc> - A <point> for the element's location.
      /// </summary>
      public loc loc;

      /// <summary>
      /// <orientation> - A <quaternion> chunk for the orientation, normally
      /// this is relative to it's parent's orientation.
      /// </summary>
      public orientation orientation;

      /// <summary>
      /// [ <roll> ] - An int chunk with a value of 1 if the element's
      /// orientation can "roll" off the vertical, and 0 if it can't.
      /// </summary>
      public @int roll;

      /// <summary>
      /// [ <facespath> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction of it's path of
      /// motion.
      /// </summary>
      public empty facespath;

      /// <summary>
      /// [ <facestarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction to another
      /// element.
      /// </summary>
      public empty facestarget;

      /// <summary>
      /// [ <orienttarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the same orientation as another
      /// element.
      /// </summary>
      public empty orienttarget;

      /// <summary>
      /// [ <boundtarget> ] - The name of the other element that this one is
      /// oriented to, if it has the facestarget or orientedtarget chunk.
      /// </summary>
      public empty boundtarget;

      /// <summary>
      /// The field of view in degrees of the camera's view from left to right.
      /// </summary>
      public @float fov;

      /// <summary>
      /// [ <scale> ] - A scale factor applied to the object before rendering.
      /// </summary>
      public scale scale;

      /// <summary>
      /// <locked> - An int chunk with the value of 1 if this element is
      /// "locked" from being edited, and a value of 0 otherwise.
      /// </summary>
      public @int locked;

      /// <summary>
      /// <controller>* - Zero or more <controller> chunks.
      /// </summary>
      public controller[] controller;

      /// <summary>
      /// <element>*  - Zero or more child elements, whose movement is relative
      /// to this element's coordinate system.
      /// </summary>
      public element[] element;
   }

   public class loc
   {
      public point point;
   }

   /// <summary>
   /// TODO: What does this mean?
   /// </summary>
   public class controller
   {
   }

   /// <summary>
   /// TODO: What does this mean?
   /// </summary>
   public class element
   {
   }
   #endregion

   #region figureelement
   public class figureelement
   {
      /// <summary>
      /// <$string> - The first thing is the name of the element.
      /// </summary>
      public String name;

      /// <summary>
      /// The second <$string> is the name of the figure that it references.
      /// </summary>
      public String figurename;

      /// <summary>
      /// <loc> - A <point> for the element's location.
      /// </summary>
      public loc loc;

      /// <summary>
      /// <orientation> - A <quaternion> chunk for the orientation, normally
      /// this is relative to it's parent's orientation.
      /// </summary>
      public orientation orientation;

      /// <summary>
      /// [ <roll> ] - An int chunk with a value of 1 if the element's
      /// orientation can "roll" off the vertical, and 0 if it can't.
      /// </summary>
      public @int roll;

      /// <summary>
      /// [ <facespath> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction of it's path of
      /// motion.
      /// </summary>
      public empty facespath;

      /// <summary>
      /// [ <facestarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction to another
      /// element.
      /// </summary>
      public empty facestarget;

      /// <summary>
      /// [ <orienttarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the same orientation as another
      /// element.
      /// </summary>
      public empty orienttarget;

      /// <summary>
      /// [ <boundtarget> ] - The name of the other element that this one is
      /// oriented to, if it has the facestarget or orientedtarget chunk.
      /// </summary>
      public empty boundtarget;

      /// <summary>
      /// [ <scale> ] - A scale factor applied to the object before rendering.
      /// </summary>
      public scale scale;

      /// <summary>
      /// This chunk has a value of 1 of the element is visible, and a value of
      /// zero if it is hidden. The default value is 1.
      /// </summary>
      public @int visibility;

      /// <summary>
      /// If present this object casts a shadow.
      /// </summary>
      public empty castshadow;

      /// <summary>
      /// If present this object shows shadows on its surface from lights that
      /// cast them.
      /// </summary>
      public empty receiveshadow;

      /// <summary>
      /// <locked> - An int chunk with the value of 1 if this element is
      /// "locked" from being edited, and a value of 0 otherwise.
      /// </summary>
      public @int locked;

      /// <summary>
      /// This chunk specifies the name and starting frame of a sequence that
      /// is applied to this figure.
      /// </summary>
      public namedsequence[] namedsequence;

      /// <summary>
      /// <controller>* - Zero or more <controller> chunks.
      /// </summary>
      public controller[] controller;

      /// <summary>
      /// <element>*  - Zero or more child elements, whose movement is relative
      /// to this element's coordinate system.
      /// </summary>
      public element[] element;
   }

   public class namedsequence
   {
      public String name;
      public Int64 startingFrame;
   }
   #endregion

   public class objectelement
   {
      /// <summary>
      /// <$string> - The first thing is the name of the element.
      /// </summary>
      public String name;

      /// <summary>
      /// The second <$string> is the name of the object that it references.
      /// </summary>
      public String objectname;

      /// <summary>
      /// <loc> - A <point> for the element's location.
      /// </summary>
      public loc loc;

      /// <summary>
      /// <orientation> - A <quaternion> chunk for the orientation, normally
      /// this is relative to it's parent's orientation.
      /// </summary>
      public orientation orientation;

      /// <summary>
      /// [ <roll> ] - An int chunk with a value of 1 if the element's
      /// orientation can "roll" off the vertical, and 0 if it can't.
      /// </summary>
      public @int roll;

      /// <summary>
      /// [ <facespath> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction of it's path of
      /// motion.
      /// </summary>
      public empty facespath;

      /// <summary>
      /// [ <facestarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction to another
      /// element.
      /// </summary>
      public empty facestarget;

      /// <summary>
      /// [ <orienttarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the same orientation as another
      /// element.
      /// </summary>
      public empty orienttarget;

      /// <summary>
      /// [ <boundtarget> ] - The name of the other element that this one is
      /// oriented to, if it has the facestarget or orientedtarget chunk.
      /// </summary>
      public empty boundtarget;

      /// <summary>
      /// [ <scale> ] - A scale factor applied to the object before rendering.
      /// </summary>
      public scale scale;

      /// <summary>
      /// This chunk has a value of 1 of the element is visible, and a value of
      /// zero if it is hidden. The default value is 1.
      /// </summary>
      public @int visibility;

      /// <summary>
      /// If present this object casts a shadow.
      /// </summary>
      public empty castshadow;

      /// <summary>
      /// If present this object shows shadows on its surface from lights that
      /// cast them.
      /// </summary>
      public empty receiveshadow;

      /// <summary>
      /// <locked> - An int chunk with the value of 1 if this element is
      /// "locked" from being edited, and a value of 0 otherwise.
      /// </summary>
      public @int locked;

      /// <summary>
      /// <controller>* - Zero or more <controller> chunks.
      /// </summary>
      public controller[] controller;

      /// <summary>
      /// <element>*  - Zero or more child elements, whose movement is relative
      /// to this element's coordinate system.
      /// </summary>
      public element[] element;
   }

   #region light
   public class light
   {
      /// <summary>
      /// <$string> - The first thing is the name of the element.
      /// </summary>
      public String name;

      /// <summary>
      /// <loc> - A <point> for the element's location.
      /// </summary>
      public loc loc;

      /// <summary>
      /// <orientation> - A <quaternion> chunk for the orientation, normally
      /// this is relative to it's parent's orientation.
      /// </summary>
      public orientation orientation;

      /// <summary>
      /// [ <roll> ] - An int chunk with a value of 1 if the element's
      /// orientation can "roll" off the vertical, and 0 if it can't.
      /// </summary>
      public @int roll;

      /// <summary>
      /// [ <facespath> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction of it's path of
      /// motion.
      /// </summary>
      public empty facespath;

      /// <summary>
      /// [ <facestarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction to another
      /// element.
      /// </summary>
      public empty facestarget;

      /// <summary>
      /// [ <orienttarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the same orientation as another
      /// element.
      /// </summary>
      public empty orienttarget;

      /// <summary>
      /// [ <boundtarget> ] - The name of the other element that this one is
      /// oriented to, if it has the facestarget or orientedtarget chunk.
      /// </summary>
      public empty boundtarget;

      /// <summary>
      /// [ <scale> ] - A scale factor applied to the object before rendering.
      /// </summary>
      public scale scale;

      /// <summary>
      /// The three values in <point> represent the red, green and blue
      /// components of the light's color. A value of 1.0 is maximum and 0.0 is
      /// minimum.
      /// </summary>
      public color color;

      /// <summary>
      /// One of these three empty chunks must be present.  They define the
      /// kind of light.
      /// </summary>
      public empty infinite;

      /// <summary>
      /// One of these three empty chunks must be present.  They define the
      /// kind of light.
      /// </summary>
      public empty local;

      /// <summary>
      /// One of these three empty chunks must be present.  They define the
      /// kind of light.
      /// </summary>
      public empty spotlight;

      /// <summary>
      /// Note: From the spec, it is not clear where this belongs.
      /// Spotlights and local lights can have a different intensity depending
      /// on the distance from an object. By default the intensity is the same.
      /// If these chunks are present then the intensity drops off linearly
      /// from full intensity at a distance of <inradius> to zero at a distance
      /// of <outradius>.
      /// </summary>
      public @float inradius;

      /// <summary>
      /// Note: From the spec, it is not clear where this belongs.
      /// Spotlights and local lights can have a different intensity depending
      /// on the distance from an object. By default the intensity is the same.
      /// If these chunks are present then the intensity drops off linearly
      /// from full intensity at a distance of <inradius> to zero at a distance
      /// of <outradius>.
      /// </summary>
      public @float outradius;

      /// <summary>
      /// Note: From the spec, it is not clear where this belongs.
      /// Spotlights also have a cone of influence. Within an angle of
      /// <inangle> to the direction of the light the intensity is full value.
      /// Between <inangle> and <outangle> it drops off linearly to zero.
      /// Outside this range it is zero.
      /// </summary>
      public @float inangle;

      /// <summary>
      /// Note: From the spec, it is not clear where this belongs.
      /// Spotlights also have a cone of influence. Within an angle of
      /// <inangle> to the direction of the light the intensity is full value.
      /// Between <inangle> and <outangle> it drops off linearly to zero.
      /// Outside this range it is zero.
      /// </summary>
      public @float outangle;

      /// <summary>
      /// If present this light casts a shadow.
      /// </summary>
      public empty castshadow;

      /// <summary>
      /// TODO: What does this mean?
      /// </summary>
      public empty percentshadow;

      /// <summary>
      ///  This chunk enables ray tracing of shadows for this light.
      /// </summary>
      public empty raytraceshadow;

      /// <summary>
      /// If <soft> is present and the light casts a ray traced shadow the the
      /// shadow is rendered with soft edges.
      /// </summary>
      public empty soft;

      /// <summary>
      /// TODO: From the spec, it is not clear where this belongs.
      /// The size of the soft shadow. For infinite lights this is the apparent
      /// width of the light source in degrees. For spotlights and local lights
      /// it represents the apparent diameter of the light as viewed by an
      /// illuminated surface.
      /// </summary>
      public @float softsize;

      /// <summary>
      /// TODO: From the spec, it is not clear where this belongs.
      /// Set the minimum number of samples used to calculate a soft shadow. An
      /// adaptive algorithm is used to speed up rendering when not in a "soft"
      /// region of the shadow.
      /// </summary>
      public @int minsamples;

      /// <summary>
      /// TODO: From the spec, it is not clear where this belongs.
      /// Set the maximum number of samples used to calculate a soft shadow. An
      /// adaptive algorithm is used to speed up rendering when not in a "soft"
      /// region of the shadow.
      /// </summary>
      public @int maxsamples;

      /// <summary>
      /// TODO: From the spec, it is not clear where this belongs.
      /// Use true Monte Carlo sampling instead of pseudo-Monte Carlo sampling.
      /// This results in a grainer look in the shadows transition region.
      /// </summary>
      public empty montecarlo;

      /// <summary>
      /// <locked> - An int chunk with the value of 1 if this element is
      /// "locked" from being edited, and a value of 0 otherwise.
      /// </summary>
      public @int locked;

      /// <summary>
      /// <controller>* - Zero or more <controller> chunks.
      /// </summary>
      public controller[] controller;

      /// <summary>
      /// <element>*  - Zero or more child elements, whose movement is relative
      /// to this element's coordinate system.
      /// </summary>
      public element[] element;
   }

   public class color
   {
      public Double red;
      public Double green;
      public Double blue;
   }
   #endregion

   public class @null
   {
      /// <summary>
      /// <$string> - The first thing is the name of the element.
      /// </summary>
      public String name;

      /// <summary>
      /// <loc> - A <point> for the element's location.
      /// </summary>
      public loc loc;

      /// <summary>
      /// <orientation> - A <quaternion> chunk for the orientation, normally
      /// this is relative to it's parent's orientation.
      /// </summary>
      public orientation orientation;

      /// <summary>
      /// [ <roll> ] - An int chunk with a value of 1 if the element's
      /// orientation can "roll" off the vertical, and 0 if it can't.
      /// </summary>
      public @int roll;

      /// <summary>
      /// [ <facespath> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction of it's path of
      /// motion.
      /// </summary>
      public empty facespath;

      /// <summary>
      /// [ <facestarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the direction to another
      /// element.
      /// </summary>
      public empty facestarget;

      /// <summary>
      /// [ <orienttarget> ] - An optional chunk that controls whether the
      /// element's orientation is relative to the same orientation as another
      /// element.
      /// </summary>
      public empty orienttarget;

      /// <summary>
      /// [ <boundtarget> ] - The name of the other element that this one is
      /// oriented to, if it has the facestarget or orientedtarget chunk.
      /// </summary>
      public empty boundtarget;

      /// <summary>
      /// [ <scale> ] - A scale factor applied to the object before rendering.
      /// </summary>
      public scale scale;

      /// <summary>
      /// <locked> - An int chunk with the value of 1 if this element is
      /// "locked" from being edited, and a value of 0 otherwise.
      /// </summary>
      public @int locked;

      /// <summary>
      /// <controller>* - Zero or more <controller> chunks.
      /// </summary>
      public controller[] controller;

      /// <summary>
      /// <element>*  - Zero or more child elements, whose movement is relative
      /// to this element's coordinate system.
      /// </summary>
      public element[] element;
   }
   #endregion
}
